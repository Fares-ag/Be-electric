
import '../utils/deterministic_id_generator.dart';
import 'asset.dart';
import 'user.dart';

enum WorkOrderStatus {
  open,
  assigned,
  inProgress,
  completed,
  closed,
  cancelled,
}

enum WorkOrderPriority { low, medium, high, urgent, critical }

enum RepairCategory {
  mechanicalHvac,
  electrical,
  structural,
  plumbing,
  interior,
  exterior,
  itLowVoltage,
  specializedEquipment,
  safetyCompliance,
  emergency,
  preventive,
  reactive,
}

class WorkOrder {
  WorkOrder({
    required this.id,
    required this.ticketNumber,
    required this.problemDescription,
    required this.requestorId,
    required this.createdAt,
    required this.updatedAt,
    this.assetId, // Optional for general facility maintenance
    this.location, // For general maintenance without asset
    this.companyId, // Company/tenant association
    this.idempotencyKey, // For duplicate prevention
    this.asset,
    this.photoPath,
    this.requestor,
    this.requestorName,
    this.primaryTechnicianId,
    List<String>? assignedTechnicianIds,
    this.assignedTechnicians,
    Map<String, int>? technicianEffortMinutes,
    this.status = WorkOrderStatus.open,
    this.priority = WorkOrderPriority.medium,
    this.assignedAt,
    this.startedAt,
    this.completedAt,
    this.closedAt,
    this.correctiveActions,
    this.recommendations,
    this.nextMaintenanceDate,
    this.requestorSignature,
    // Pause/Resume fields
    this.isPaused = false,
    this.pausedAt,
    this.pauseReason,
    this.resumedAt,
    this.pauseHistory,
    this.technicianSignature,
    this.notes,
    this.category,
    this.isOffline = false,
    this.lastSyncedAt,
    this.laborCost,
    this.partsCost,
    this.totalCost,
    // Enhanced analytics fields
    this.firstResponseTime,
    this.actualStartTime,
    this.actualEndTime,
    this.estimatedDuration,
    this.actualDuration,
    this.partsUsed,
    this.actualCost,
    this.rootCause,
    this.failureMode,
    this.severityLevel,
    this.isRepeatFailure,
    this.workCategory,
    this.estimatedCost,
    this.laborHours,
    this.technicianNotes,
    this.customerSignature,
    this.customerName,
    this.customerPhone,
    this.customerEmail,
    // Completion photo fields
    this.completionPhotoPath,
    this.beforePhotoPath,
    this.afterPhotoPath,
  })  : assignedTechnicianIds = assignedTechnicianIds ?? <String>[],
        technicianEffortMinutes = technicianEffortMinutes != null
            ? Map<String, int>.from(technicianEffortMinutes)
            : null;

  /// Create a new work order with idempotency key
  factory WorkOrder.create({
    required String ticketNumber,
    required String problemDescription,
    required String requestorId,
    String? assetId,
    String? location,
    String? photoPath,
    WorkOrderPriority priority = WorkOrderPriority.medium,
    RepairCategory? category,
    String? notes,
    String? sourceId, // For idempotency key generation
  }) {
    final now = DateTime.now();
    final idempotencyKey = sourceId != null
        ? DeterministicIdGenerator.generateIdempotencyKey(
            type: 'wo',
            sourceId: sourceId,
            timestamp: now,
          )
        : null;

    return WorkOrder(
      id: '', // Will be generated by the service
      ticketNumber: ticketNumber,
      assetId: assetId,
      location: location,
      problemDescription: problemDescription,
      requestorId: requestorId,
      createdAt: now,
      updatedAt: now,
      idempotencyKey: idempotencyKey,
      photoPath: photoPath,
      priority: priority,
      category: category,
      notes: notes,
    );
  }
  factory WorkOrder.fromMap(Map<String, dynamic> data) => WorkOrder(
        id: data['id'] as String,
        ticketNumber: data['ticketNumber'] as String,
        assetId: data['assetId'] as String?,
        location: data['location'] as String?, // For general maintenance
        companyId: data['companyId'] as String?,
        problemDescription: data['problemDescription'] as String,
        requestorId: data['requestorId'] as String,
        requestorName: data['requestorName'] as String?,
        createdAt: _parseDate(data['createdAt']) ?? DateTime.now(),
        idempotencyKey: data['idempotencyKey'] as String?,
        photoPath: data['photoPath'] as String?,
        primaryTechnicianId: data['primaryTechnicianId'] as String? ??
            data['assignedTechnicianId'] as String?,
        assignedTechnicianIds: _parseTechnicianIdList(data),
        technicianEffortMinutes: _parseTechnicianEffortMap(
          data['technicianEffortMinutes'],
          fallbackTechnicianId: data['assignedTechnicianId'] as String?,
        ),
        status: WorkOrderStatus.values.firstWhere(
          (e) => e.name == data['status'],
          orElse: () => WorkOrderStatus.open,
        ),
        priority: WorkOrderPriority.values.firstWhere(
          (e) => e.name == data['priority'],
          orElse: () => WorkOrderPriority.medium,
        ),
        assignedAt: _parseDate(data['assignedAt']),
        startedAt: _parseDate(data['startedAt']),
        completedAt: _parseDate(data['completedAt']),
        closedAt: _parseDate(data['closedAt']),
        correctiveActions: data['correctiveActions'] as String?,
        recommendations: data['recommendations'] as String?,
        nextMaintenanceDate: _parseDate(data['nextMaintenanceDate']),
        requestorSignature: data['requestorSignature'] as String?,
        technicianSignature: data['technicianSignature'] as String?,
        notes: data['notes'] as String?,
        category: data['category'] != null
            ? RepairCategory.values.firstWhere(
                (e) => e.name == data['category'],
                orElse: () => RepairCategory.reactive,
              )
            : null,
        estimatedCost: (data['estimatedCost'] as num?)?.toDouble(),
        actualCost: (data['actualCost'] as num?)?.toDouble(),
        totalCost: (data['totalCost'] as num?)?.toDouble(),
        partsUsed: _parseListFromDynamic(data['partsUsed']),
        laborHours: (data['laborHours'] as num?)?.toDouble(),
        technicianNotes: data['technicianNotes'] as String?,
        customerSignature: data['customerSignature'] as String?,
        customerName: data['customerName'] as String?,
        customerPhone: data['customerPhone'] as String?,
        customerEmail: data['customerEmail'] as String?,
        // Completion photo fields
        completionPhotoPath: data['completionPhotoPath'] as String?,
        beforePhotoPath: data['beforePhotoPath'] as String?,
        afterPhotoPath: data['afterPhotoPath'] as String?,
        updatedAt: _parseDate(data['updatedAt']) ?? DateTime.now(),
        firstResponseTime: _parseDate(data['firstResponseTime']),
        actualStartTime: _parseDate(data['actualStartTime']),
        actualEndTime: _parseDate(data['actualEndTime']),
        estimatedDuration: data['estimatedDuration'] != null
            ? Duration(minutes: (data['estimatedDuration'] as num).toInt())
            : null,
        actualDuration: data['actualDuration'] != null
            ? Duration(minutes: (data['actualDuration'] as num).toInt())
            : null,
        rootCause: data['rootCause'] as String?,
        failureMode: data['failureMode'] as String?,
        severityLevel: (data['severityLevel'] as num?)?.toInt(),
        isRepeatFailure: _parseBoolFromDynamic(data['isRepeatFailure']),
        workCategory: data['workCategory'] as String?,
        // Pause/Resume fields
        isPaused: _parseBoolFromDynamic(data['isPaused']) ?? false,
        pausedAt: _parseDate(data['pausedAt']),
        pauseReason: data['pauseReason'] as String?,
        resumedAt: _parseDate(data['resumedAt']),
        pauseHistory: _parsePauseHistory(data['pauseHistory']),
        // Offline sync fields
        isOffline: _parseBoolFromDynamic(data['isOffline']) ?? false,
        lastSyncedAt: _parseDate(data['lastSyncedAt']),
        laborCost: (data['laborCost'] as num?)?.toDouble(),
        partsCost: (data['partsCost'] as num?)?.toDouble(),
      );

  /// Helper method to parse DateTime from Supabase (ISO8601 string) or DateTime
  static DateTime? _parseDate(dynamic value) {
    if (value == null) return null;
    if (value is DateTime) return value;
    if (value is String) return DateTime.tryParse(value);
    return null;
  }

  /// Safely parse boolean from dynamic value
  /// Handles: bool, int (0/1), null
  static bool? _parseBoolFromDynamic(dynamic value) {
    if (value == null) return null;
    if (value is bool) return value;
    if (value is int) return value == 1; // 0 → false, 1 → true
    if (value is String) {
      if (value.toLowerCase() == 'true') return true;
      if (value.toLowerCase() == 'false') return false;
    }
    return null;
  }

  /// Safely parse List<String> from dynamic value
  /// Handles: List, String "[]", null
  static List<String>? _parseListFromDynamic(dynamic value) {
    if (value == null) return null;
    if (value is List) {
      try {
        return List<String>.from(value);
      } catch (e) {
        return null;
      }
    }
    if (value is String) {
      // Handle string "[]" stored in database
      if (value == '[]' || value.isEmpty) return null;
    }
    return null;
  }

  static List<String>? _parseStringList(dynamic value) {
    final parsed = _parseListFromDynamic(value);
    if (parsed != null) return parsed;
    if (value is String && value.isNotEmpty) {
      return <String>[value];
    }
    return null;
  }

  static List<String> _parseTechnicianIdList(Map<String, dynamic> data) {
    final raw = _parseStringList(data['assignedTechnicianIds']);
    if (raw != null && raw.isNotEmpty) {
      return raw;
    }
    final single = data['assignedTechnicianId'] as String?;
    return single != null ? <String>[single] : <String>[];
  }

  static Map<String, int>? _parseTechnicianEffortMap(
    dynamic value, {
    String? fallbackTechnicianId,
  }) {
    if (value == null) {
      return fallbackTechnicianId != null ? <String, int>{fallbackTechnicianId: 0} : null;
    }
    if (value is Map) {
      try {
        return value.map(
          (key, val) => MapEntry(
            key.toString(),
            val is num ? val.toInt() : int.tryParse(val.toString()) ?? 0,
          ),
        );
      } catch (_) {
        return fallbackTechnicianId != null
            ? <String, int>{fallbackTechnicianId: 0}
            : null;
      }
    }
    return fallbackTechnicianId != null
        ? <String, int>{fallbackTechnicianId: 0}
        : null;
  }

  /// Safely parse pause history from dynamic value
  /// Handles: List<Map>, String "[]", null
  static List<Map<String, dynamic>>? _parsePauseHistory(dynamic value) {
    if (value == null) return null;
    if (value is List) {
      try {
        return List<Map<String, dynamic>>.from(
          value.map((e) => Map<String, dynamic>.from(e as Map)),
        );
      } catch (e) {
        return null;
      }
    }
    if (value is String) {
      // Handle string "[]" stored in database
      if (value == '[]' || value.isEmpty) return null;
    }
    return null;
  }

  final String id;
  final String ticketNumber;
  final String? assetId; // Optional for general facility maintenance
  final Asset? asset;
  final String? location; // For general maintenance without asset
  final String? companyId; // Company/tenant association
  final String problemDescription;
  final String? idempotencyKey; // For duplicate prevention
  final String? photoPath;
  final String requestorId;
  final User? requestor;
  /// Optional free-text requestor name provided at creation (e.g. person on site)
  final String? requestorName;
  final String? primaryTechnicianId;
  final List<String> assignedTechnicianIds;
  final List<User>? assignedTechnicians;
  final Map<String, int>? technicianEffortMinutes;
  final WorkOrderStatus status;
  final WorkOrderPriority priority;
  final DateTime createdAt;
  final DateTime? assignedAt;
  final DateTime? startedAt;
  final DateTime? completedAt;
  final DateTime? closedAt;
  final String? correctiveActions;
  final String? recommendations;
  final DateTime? nextMaintenanceDate;
  final String? requestorSignature;
  // Pause/Resume fields
  final bool isPaused;
  final DateTime? pausedAt;
  final String? pauseReason;
  final DateTime? resumedAt;
  final List<Map<String, dynamic>>?
      pauseHistory; // Track all pauses with reasons
  final String? technicianSignature;
  final String? notes;
  final RepairCategory? category;
  final bool isOffline;
  final DateTime? lastSyncedAt;
  final double? laborCost;
  final double? partsCost;
  final double? totalCost;
  // Enhanced analytics fields
  final DateTime? firstResponseTime;
  final DateTime? actualStartTime;
  final DateTime? actualEndTime;
  final Duration? estimatedDuration;
  final Duration? actualDuration;
  final List<String>? partsUsed;
  final double? actualCost;
  final String? rootCause;
  final String? failureMode;
  final int? severityLevel;
  final bool? isRepeatFailure;
  final String? workCategory;
  final DateTime updatedAt;
  final double? estimatedCost;
  final double? laborHours;
  final String? technicianNotes;
  final String? customerSignature;
  final String? customerName;
  final String? customerPhone;
  final String? customerEmail;
  // Completion photo fields
  final String? completionPhotoPath;
  final String? beforePhotoPath;
  final String? afterPhotoPath;

  WorkOrder copyWith({
    String? id,
    String? ticketNumber,
    String? assetId,
    Asset? asset,
    String? location,
    String? companyId,
    String? problemDescription,
    String? photoPath,
    String? requestorId,
    User? requestor,
    String? requestorName,
    String? primaryTechnicianId,
    List<String>? assignedTechnicianIds,
    List<User>? assignedTechnicians,
    Map<String, int>? technicianEffortMinutes,
    String? assignedTechnicianId,
    User? assignedTechnician,
    WorkOrderStatus? status,
    WorkOrderPriority? priority,
    DateTime? createdAt,
    DateTime? assignedAt,
    DateTime? startedAt,
    DateTime? completedAt,
    DateTime? closedAt,
    String? correctiveActions,
    String? recommendations,
    DateTime? nextMaintenanceDate,
    String? requestorSignature,
    String? technicianSignature,
    String? notes,
    RepairCategory? category,
    bool? isOffline,
    DateTime? lastSyncedAt,
    double? laborCost,
    double? partsCost,
    double? totalCost,
    // Enhanced analytics fields
    DateTime? firstResponseTime,
    DateTime? actualStartTime,
    DateTime? actualEndTime,
    Duration? estimatedDuration,
    Duration? actualDuration,
    List<String>? partsUsed,
    double? actualCost,
    String? rootCause,
    String? failureMode,
    int? severityLevel,
    bool? isRepeatFailure,
    String? workCategory,
    DateTime? updatedAt,
    // Completion photo fields
    String? completionPhotoPath,
    String? beforePhotoPath,
    String? afterPhotoPath,
    // Pause/Resume fields
    bool? isPaused,
    DateTime? pausedAt,
    String? pauseReason,
    DateTime? resumedAt,
    List<Map<String, dynamic>>? pauseHistory,
  }) =>
      WorkOrder(
        id: id ?? this.id,
        ticketNumber: ticketNumber ?? this.ticketNumber,
        assetId: assetId ?? this.assetId,
        asset: asset ?? this.asset,
        location: location ?? this.location,
        companyId: companyId ?? this.companyId,
        problemDescription: problemDescription ?? this.problemDescription,
        photoPath: photoPath ?? this.photoPath,
        requestorId: requestorId ?? this.requestorId,
        requestor: requestor ?? this.requestor,
        requestorName: requestorName ?? this.requestorName,
        primaryTechnicianId: primaryTechnicianId ??
            assignedTechnicianId ??
            this.primaryTechnicianId ??
            ((assignedTechnicianIds ??
                        this.assignedTechnicianIds)
                    .isNotEmpty
                ? (assignedTechnicianIds ?? this.assignedTechnicianIds).first
                : null),
        assignedTechnicianIds: assignedTechnicianIds ??
            (assignedTechnicianId != null
                ? <String>[assignedTechnicianId]
                : this.assignedTechnicianIds),
        assignedTechnicians: assignedTechnicians ??
            (assignedTechnician != null
                ? <User>[assignedTechnician]
                : this.assignedTechnicians),
        technicianEffortMinutes:
            technicianEffortMinutes ?? this.technicianEffortMinutes,
        status: status ?? this.status,
        priority: priority ?? this.priority,
        createdAt: createdAt ?? this.createdAt,
        assignedAt: assignedAt ?? this.assignedAt,
        startedAt: startedAt ?? this.startedAt,
        completedAt: completedAt ?? this.completedAt,
        closedAt: closedAt ?? this.closedAt,
        correctiveActions: correctiveActions ?? this.correctiveActions,
        recommendations: recommendations ?? this.recommendations,
        nextMaintenanceDate: nextMaintenanceDate ?? this.nextMaintenanceDate,
        requestorSignature: requestorSignature ?? this.requestorSignature,
        technicianSignature: technicianSignature ?? this.technicianSignature,
        notes: notes ?? this.notes,
        category: category ?? this.category,
        isOffline: isOffline ?? this.isOffline,
        lastSyncedAt: lastSyncedAt ?? this.lastSyncedAt,
        laborCost: laborCost ?? this.laborCost,
        partsCost: partsCost ?? this.partsCost,
        totalCost: totalCost ?? this.totalCost,
        // Enhanced analytics fields
        firstResponseTime: firstResponseTime ?? this.firstResponseTime,
        actualStartTime: actualStartTime ?? this.actualStartTime,
        actualEndTime: actualEndTime ?? this.actualEndTime,
        estimatedDuration: estimatedDuration ?? this.estimatedDuration,
        actualDuration: actualDuration ?? this.actualDuration,
        partsUsed: partsUsed ?? this.partsUsed,
        actualCost: actualCost ?? this.actualCost,
        rootCause: rootCause ?? this.rootCause,
        failureMode: failureMode ?? this.failureMode,
        severityLevel: severityLevel ?? this.severityLevel,
        isRepeatFailure: isRepeatFailure ?? this.isRepeatFailure,
        workCategory: workCategory ?? this.workCategory,
        updatedAt: updatedAt ?? this.updatedAt,
        // Completion photo fields
        completionPhotoPath: completionPhotoPath ?? this.completionPhotoPath,
        beforePhotoPath: beforePhotoPath ?? this.beforePhotoPath,
        afterPhotoPath: afterPhotoPath ?? this.afterPhotoPath,
        // Pause/Resume fields
        isPaused: isPaused ?? this.isPaused,
        pausedAt: pausedAt ?? this.pausedAt,
        pauseReason: pauseReason ?? this.pauseReason,
        resumedAt: resumedAt ?? this.resumedAt,
        pauseHistory: pauseHistory ?? this.pauseHistory,
      );

  String get statusDisplayName {
    switch (status) {
      case WorkOrderStatus.open:
        return 'Open';
      case WorkOrderStatus.assigned:
        return 'Assigned';
      case WorkOrderStatus.inProgress:
        return 'In Progress';
      case WorkOrderStatus.completed:
        return 'Completed';
      case WorkOrderStatus.closed:
        return 'Closed';
      case WorkOrderStatus.cancelled:
        return 'Cancelled';
    }
  }

  String get priorityDisplayName {
    switch (priority) {
      case WorkOrderPriority.low:
        return 'Low';
      case WorkOrderPriority.medium:
        return 'Medium';
      case WorkOrderPriority.high:
        return 'High';
      case WorkOrderPriority.urgent:
        return 'Urgent';
      case WorkOrderPriority.critical:
        return 'Critical';
    }
  }

  String get categoryDisplayName {
    switch (category) {
      case RepairCategory.mechanicalHvac:
        return 'Mechanical & HVAC';
      case RepairCategory.electrical:
        return 'Electrical';
      case RepairCategory.structural:
        return 'Structural';
      case RepairCategory.plumbing:
        return 'Plumbing & Water';
      case RepairCategory.interior:
        return 'Interior';
      case RepairCategory.exterior:
        return 'Exterior';
      case RepairCategory.itLowVoltage:
        return 'IT & Low Voltage';
      case RepairCategory.specializedEquipment:
        return 'Specialized Equipment';
      case RepairCategory.safetyCompliance:
        return 'Safety & Compliance';
      case RepairCategory.emergency:
        return 'Emergency';
      case RepairCategory.preventive:
        return 'Preventive';
      case RepairCategory.reactive:
        return 'Reactive';
      case null:
        return 'Not Specified';
    }
  }

  bool get isOpen => status == WorkOrderStatus.open;
  bool get isAssigned => status == WorkOrderStatus.assigned;
  bool get isInProgress => status == WorkOrderStatus.inProgress;
  bool get isCompleted => status == WorkOrderStatus.completed;
  bool get isClosed => status == WorkOrderStatus.closed;
  bool get isCancelled => status == WorkOrderStatus.cancelled;

  bool get isHighPriority =>
      priority == WorkOrderPriority.high ||
      priority == WorkOrderPriority.urgent ||
      priority == WorkOrderPriority.critical;
  bool get isOverdue =>
      status != WorkOrderStatus.closed &&
      status != WorkOrderStatus.cancelled &&
      DateTime.now().difference(createdAt).inDays > 7;

  // Convenience getters for asset information
  String? get assetName => asset?.name;
  String? get assetLocation =>
      asset?.location ??
      location; // Fallback to location field for general maintenance
  String? get assignedTechnicianId =>
      primaryTechnicianId ??
      (assignedTechnicianIds.isNotEmpty ? assignedTechnicianIds.first : null);

  User? get assignedTechnician =>
      assignedTechnicians != null && assignedTechnicians!.isNotEmpty
          ? assignedTechnicians!.first
          : null;

  String? get assignedTechnicianName => assignedTechnician?.name;

  int technicianMinutesFor(String technicianId) =>
      technicianEffortMinutes?[technicianId] ??
      actualDuration?.inMinutes ??
      estimatedDuration?.inMinutes ??
      0;

  bool hasTechnician(String technicianId) =>
      assignedTechnicianIds.contains(technicianId);

  // Data conversion methods
  Map<String, dynamic> toMap() => {
        'id': id,
        'ticketNumber': ticketNumber,
        'assetId': assetId,
        'location': location, // For general maintenance
        'companyId': companyId,
        'problemDescription': problemDescription,
        'requestorId': requestorId,
        'requestorName': requestorName,
        'createdAt': createdAt.toIso8601String(),
        'idempotencyKey': idempotencyKey,
        'photoPath': photoPath,
        'primaryTechnicianId':
            primaryTechnicianId ?? (assignedTechnicianIds.isNotEmpty ? assignedTechnicianIds.first : null),
        'assignedTechnicianId':
            primaryTechnicianId ?? (assignedTechnicianIds.isNotEmpty ? assignedTechnicianIds.first : null),
        'assignedTechnicianIds': assignedTechnicianIds,
        'technicianEffortMinutes': technicianEffortMinutes,
        'status': status.name,
        'priority': priority.name,
        'assignedAt': assignedAt?.toIso8601String(),
        'startedAt': startedAt?.toIso8601String(),
        'completedAt': completedAt?.toIso8601String(),
        'closedAt': closedAt?.toIso8601String(),
        'correctiveActions': correctiveActions,
        'recommendations': recommendations,
        'category': category?.name,
        'estimatedCost': estimatedCost,
        'actualCost': actualCost,
        'totalCost': totalCost,
        'partsUsed': partsUsed,
        'laborHours': laborHours,
        'technicianNotes': technicianNotes,
        'customerSignature': customerSignature,
        'customerName': customerName,
        'customerPhone': customerPhone,
        'customerEmail': customerEmail,
        // Completion photo fields
        'completionPhotoPath': completionPhotoPath,
        'beforePhotoPath': beforePhotoPath,
        'afterPhotoPath': afterPhotoPath,
        'updatedAt': updatedAt.toIso8601String(),
        'firstResponseTime': firstResponseTime?.toIso8601String(),
        'actualStartTime': actualStartTime?.toIso8601String(),
        'actualEndTime': actualEndTime?.toIso8601String(),
        'estimatedDuration': estimatedDuration,
        'actualDuration': actualDuration,
        'rootCause': rootCause,
        'failureMode': failureMode,
        'severityLevel': severityLevel,
        'isRepeatFailure': isRepeatFailure,
        'workCategory': workCategory,
      };
}

extension RepairCategoryExtension on RepairCategory {
  String get displayName {
    switch (this) {
      case RepairCategory.mechanicalHvac:
        return 'Mechanical/HVAC';
      case RepairCategory.electrical:
        return 'Electrical';
      case RepairCategory.structural:
        return 'Structural';
      case RepairCategory.plumbing:
        return 'Plumbing';
      case RepairCategory.interior:
        return 'Interior';
      case RepairCategory.exterior:
        return 'Exterior';
      case RepairCategory.itLowVoltage:
        return 'IT/Low Voltage';
      case RepairCategory.specializedEquipment:
        return 'Specialized Equipment';
      case RepairCategory.safetyCompliance:
        return 'Safety/Compliance';
      case RepairCategory.emergency:
        return 'Emergency';
      case RepairCategory.preventive:
        return 'Preventive';
      case RepairCategory.reactive:
        return 'Reactive';
    }
  }
}
